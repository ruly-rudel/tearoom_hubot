# Description:
#   Hubot RSS Reader
#
# Commands:
#   hubot rss add https://github.com/shokai.atom
#   hubot rss delete http://shokai.org/blog/feed
#   hubot rss delete #room_name
#   hubot rss list
#   hubot rss dump
#
# Author:
#   @shokai

'use strict'


path         = require 'path'
_            = require 'lodash'
debug        = require('debug')('hubot-rss-reader')
Promise      = require 'bluebird'
# RSSChecker = require path.join __dirname, '../libs/rss-checker'
FindRSS      = Promise.promisify require 'find-rss'
RSSChecker   = require 'hubot-dropbox-rss-reformatter'

## config
package_json = require path.join __dirname, '../package.json'
process.env.HUBOT_RSS_INTERVAL  ||= 60*10  # 10 minutes
process.env.HUBOT_RSS_HEADER    ||= ':sushi:'
process.env.HUBOT_RSS_USERAGENT ||= "hubot-rss-reader/#{package_json.version}"

module.exports = (robot) ->

  logger =
    info: (msg) ->
      return debug msg if debug.enabled
      msg = JSON.stringify msg if typeof msg isnt 'string'
      robot.logger.info "#{debug.namespace}: #{msg}"
    error: (msg) ->
      return debug msg if debug.enabled
      msg = JSON.stringify msg if typeof msg isnt 'string'
      robot.logger.error "#{debug.namespace}: #{msg}"

  send_queue = []
  room_storm_count = {}

  send = (envelope, body) ->
    send_queue.push {envelope: envelope, body: body}

  setInterval ->
    return if typeof robot.send isnt 'function'
    return if send_queue.length < 1
    msg = send_queue.shift()

    try
      robot.send msg.envelope, msg.body
    catch err
      logger.error "Error on sending to room: \"#{msg.envelope.room}\""
      logger.error err
  , 500

  checker = new RSSChecker robot

  ## wait until connect redis
  robot.brain.once 'loaded', ->
    run = (opts) ->
      logger.info "checker start"
      room_storm_count = {}
      checker.check opts
      .then ->
        logger.info "wait #{process.env.HUBOT_RSS_INTERVAL} seconds, cleared room storm count"
        setTimeout run, 1000 * process.env.HUBOT_RSS_INTERVAL
      , (err) ->
        logger.error err
        logger.info "wait #{process.env.HUBOT_RSS_INTERVAL} seconds, cleared room storm count"
        setTimeout run, 1000 * process.env.HUBOT_RSS_INTERVAL

    run {init: yes}


  last_state_is_error = {}
  packed_items = []

  checker.on 'new entry', (entry) ->
    last_state_is_error[entry.feed.url] = false
    for room, feeds of checker.getAllFeeds()
      if room isnt entry.args.room and
         _.include feeds, entry.feed.url
        logger.info "#{entry.title} #{entry.url} => #{room}"
        packed_items.push({room: room, entry: entry.toString()})
        #send {room: room}, entry.toString()


  # 日頃のRSSチェック
  checker.on 'checked the site', (rss) ->

    item_queue = []

    for item in packed_items
      # 連投制限3回まで
      console.log("room:" , item.room , " storm:" , room_storm_count[item.room])

      if room_storm_count[item.room] == -1
        continue

      if room_storm_count[item.room]
        room_storm_count[item.room] += 1
      else
        room_storm_count[item.room] = 1

      if room_storm_count[item.room] > 3  || room_storm_count[item.room] == -1
        if room_storm_count[item.room] != -1
          item_queue.push {room: item.room, entry: ":star2: 連投は禁止って言われてるから、３つまで表示したネー！"}
          room_storm_count[item.room] = -1
        continue

      item_queue.unshift item

    for item in item_queue

      send {room: item.room}, item.entry

    packed_items = []

  checker.on 'error', (err) ->
    logger.error err
    if last_state_is_error[err.feed.url]  # reduce error notify
      return
    last_state_is_error[err.feed.url] = true
    for room, feeds of checker.getAllFeeds()
      if _.include feeds, err.feed.url
        true
        ## for debug
        ## send {room: room}, "RSSノードの監視処理にエラーが発生した。 #{err.feed.url} - #{err.error.message or err.error}"

  robot.respond /rss\s+(add|register|追加|reg)\s+(https?:\/\/[^\s]+)$/im, (msg) ->
    url = msg.match[2].trim()
    last_state_is_error[url] = false
    logger.info "add #{url}"
    checker.addFeed msg.message.room, url
    .then (res) ->
      new Promise (resolve) ->
        msg.send res
        resolve url
    .then (url) ->
      checker.fetch {url: url, room: msg.message.room}
    .then (entries) ->
      entry = entries[0]
      if entry
        send {room: msg.message.room}, entry.toString()
        send {room: msg.message.room}, ":star2: Latest article はこれデースｗｗｗｗｗｗ"
      else
        msg.send "提督ゥ、これはRSSじゃないデース！"
        checker.deleteFeed msg.message.room, url

    , (err) ->
      msg.send "テーーートクーーーッｗｗｗｗ #{err}"
      checker.deleteFeed msg.message.room, url

      .then ->
        FindRSS url
      .then (feeds) ->
        return if feeds?.length < 1
        msg.send _.flatten([
          "ウゥーン、別なRSSを見つけたケド……"
          feeds.map (i) -> " * #{i.url}"
        ]).join '\n'
    .catch (err) ->
      msg.send "提督ゥ、これはRSSじゃないネ！ #{err}"
      logger.error err.stack


  robot.respond /rss\s+(delete|削除|remove|del|rm)\s+(https?:\/\/[^\s]+)$/im, (msg) ->
    url = msg.match[2].trim()
    logger.info "delete #{url}"
    checker.deleteFeed msg.message.room, url
    .then (res) ->
      msg.send res
    .catch (err) ->
      msg.send err
      logger.error err.stack

  robot.respond /rss\s+(elete|削除|remove|del|rm)\s+#([^\s]+)$/im, (msg) ->
    room = msg.match[2].trim()
    logger.info "delete ##{room}"
    checker.deleteRoom room
    .then (res) ->
      msg.send res
    .catch (err) ->
      msg.send err
      logger.error err.stack

  robot.respond /rss\s+(list|リスト|一覧|li|l)$/i, (msg) ->
    feeds = checker.getFeeds msg.message.room
    if feeds.length < 1
      msg.send "このchにはRSSは登録されてないネー！"
    else
      msg.send feeds.join "\n"

  robot.respond /rss dump$/i, (msg) ->
    feeds = checker.getAllFeeds()
    msg.send JSON.stringify feeds, null, 2


  robot.respond /rss$/im, (msg) ->
    room = msg.match[0].trim()
    msg.send "丙提督ゥ！　You need help???? \nRSSノード監視機能はchごとに設定できるのデース。\n私の機能を使うにはこのコマンドを打ち込むのネ！\n```* RSSを新たにこのchで登録する -> kongo rss add <URL>\n* このchで登録されているRSSを一覧 -> kongo rss list\n* 指定のRSSをこのchから削除する -> kongo rss delete <URL>```\n"
